#!/bin/zsh

# Constants
readonly AGENT_SOCKET="$HOME/.ssh/.ssh-agent-socket"
readonly AGENT_INFO="$HOME/.ssh/.ssh-agent-info"

# Detect only the architecture
detect_architecture() {
    local arch=$(uname -m)
    case "$arch" in
        x86_64) echo 'x86_64' ;;
        aarch64|arm64) echo 'arm64' ;;  # Handle both identifiers for ARM64
        *) echo 'unknown' ;;
    esac
}

# Detect shell platform
detect_shell_platform() {
    case "$OSTYPE" in
        linux*) echo 'LINUX' ;;
        darwin*) echo 'OSX' ;;
        freebsd*) echo 'BSD' ;;
        cygwin*) echo 'CYGWIN' ;;
        *) echo 'OTHER' ;;
    esac
}

# History management
setup_history() {
    # Path to the history file
    export HISTFILE="$HOME/.zsh_history"

    # Number of commands to save in the history file
    export HISTSIZE=10000
    export SAVEHIST=10000

    # Options to manage how history is stored and shared
    setopt SHARE_HISTORY          # Share history between all sessions
    setopt INC_APPEND_HISTORY_TIME
    setopt HIST_EXPIRE_DUPS_FIRST # Expire duplicate entries first when trimming history
    setopt HIST_REDUCE_BLANKS     # Remove superfluous blanks before saving entry
    setopt HIST_IGNORE_ALL_DUPS   # Ignore duplicated entries
    setopt HIST_IGNORE_SPACE      # Don't record an entry starting with a space
    setopt HIST_FIND_NO_DUPS      # Do not display duplicates in history search
    setopt HIST_VERIFY            # Show command with history expansion to user before running it
}


# Handles the initialization and maintenance of an SSH agent to manage SSH keys.
handle_ssh_agent() {
    local ssh_agent_info="$HOME/.ssh/.ssh-agent-info"
    local agent_socket="$HOME/.ssh/.ssh-agent-socket"

    # Load existing agent configuration if available
    if [[ -s "$ssh_agent_info" ]]; then
        source "$ssh_agent_info"
    fi

    # Check if SSH agent needs restarting
    if ! ssh-add -l &>/dev/null || [[ ! -S "$agent_socket" ]]; then
        echo "SSH Agent not running or socket not found, restarting agent..."
        restart_ssh_agent "$agent_socket" "$ssh_agent_info"
    else
        echo "SSH Agent already running."
    fi
}

# Restarts the SSH agent and updates the agent information files
restart_ssh_agent() {
    local agent_socket=$1
    local agent_info_file=$2

    # Ensure old sockets are removed for security
    [[ -S "$agent_socket" ]] && rm "$agent_socket"

    # Start new SSH agent and save its configuration
    echo "Starting new SSH agent..."
    ssh-agent -a "$agent_socket" > "$agent_info_file"
    source "$agent_info_file"
    ssh-add
}

# Update PS1 prompt
update_ps1() {
    local os_type=$(detect_shell_platform)
    local arch_type=$(detect_architecture)
    local platform_cmd="${os_type}-${arch_type}"
    local powerline_cmd

    case "$platform_cmd" in
        OSX-x86_64) powerline_cmd="$HOME/bin/powerline-go-darwin-amd64" ;;
        OSX-arm64) powerline_cmd="$HOME/bin/powerline-go-darwin-arm64" ;;
        LINUX-arm64) powerline_cmd="$HOME/bin/powerline-go-linux-arm64" ;;
        LINUX-x86_64) powerline_cmd="$HOME/bin/powerline-go-linux-amd64" ;;
    esac

    # Check if the powerline_cmd is executable
    if [[ -n "$powerline_cmd" ]] && [[ -x "$powerline_cmd" ]]; then
        PS1="$($powerline_cmd -error $? -jobs $(jobs -p | wc -l))"
    else
        echo "Error: powerline-go command not found or not executable at $powerline_cmd"
        PS1="[%n@%m %~]%# "
    fi
}


# Sets up the general environment variables and configurations.
setup_environment() {
    setup_path
    setup_locale
    setup_editors
    setup_misc
    setup_fzf
}

# Configures system and user paths.
setup_path() {
    local system_paths=("/usr/local/bin" "/usr/local/go/bin")
    local user_paths=("$HOME/bin" "$HOME/.local/bin")
    local os_type=$(detect_shell_platform)

    if [[ "$os_type" == "OSX" ]]; then
        path=($(/opt/homebrew/bin/brew --prefix)/bin $(/opt/homebrew/bin/brew --prefix)/sbin $path)
    else
        path=($path $HOME/bin /usr/local/bin $HOME/.local/bin /usr/local/go/bin)
    fi
}

# Sets up locale and timezone settings.
setup_locale() {
    export LC_ALL="en_US.UTF-8"
    export LANG="en_US.UTF-8"
    export TZ="US/Pacific"
}

# Configures default editors and related settings.
setup_editors() {
    export EDITOR="vim -f"
    export P4EDITOR="$EDITOR"
    export VISUAL="$EDITOR"
}

# Miscellaneous environment settings.
setup_misc() {
    export VAGRANT_DEFAULT_PROVIDER="aws"
    export GCC_COLORS="error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01"
}

setup_fzf() {
    local os_type=$(detect_shell_platform)
    local arch_type=$(detect_architecture)
    local platform_cmd="${os_type}-${arch_type}"
    local fzf_cmd
    local common_fzf_link="$HOME/bin/fzf"

    case "$platform_cmd" in
        OSX-x86_64) fzf_cmd="$HOME/bin/fzf-darwin-amd64" ;;
        OSX-arm64) fzf_cmd="$HOME/bin/fzf-darwin-arm64" ;;
        LINUX-arm64) fzf_cmd="$HOME/bin/fzf-linux-arm64" ;;
        LINUX-x86_64) fzf_cmd="$HOME/bin/fzf-linux-amd64" ;;
    esac

    # Check if the specific binary exists and is executable
    if [[ -n "$fzf_cmd" ]] && [[ -x "$fzf_cmd" ]]; then
        # Only create symlink if it does not already exist or points to a different target
        if [[ ! -L "$common_fzf_link" ]] || [[ "$(readlink -- "$common_fzf_link")" != "$fzf_cmd" ]]; then
            ln -sf "$fzf_cmd" "$common_fzf_link"
            echo "fzf symlink created at $common_fzf_link"
        else
            echo "fzf symlink already exists and is correctly set."
        fi
        # Check the symlink itself if it's executable
        if [[ -x "$common_fzf_link" ]]; then
            echo "fzf properly setup"
        else
            echo "Error: Symlink at $common_fzf_link is not executable. Check permissions or target validity."
        fi
    else
        echo "Warning: fzf binary not found or not executable at $fzf_cmd. Please ensure the appropriate binary is available."
    fi
}


# GOPATH setup
setup_gopath() {
    if [[ -z "$GOPATH" ]]; then
        export GOPATH="$HOME/workspace/go"
        mkdir -p "$GOPATH"
        path=($path $GOPATH/bin)
        export GOPROXY="https://proxy.golang.org,direct"
    fi
}

# Platform-specific aliases and setup
setup_platform_specific() {
    local os_type=$(detect_shell_platform)

    case "$os_type" in
        OSX)
            export HOMEBREW_NO_ANALYTICS=1
            #alias slock='pmset displaysleepnow && ssh 172.17.122.15 "DISPLAY=:0 slock"'
            alias brew="/opt/homebrew/bin/brew"
            if (( $+commands[brew] )) && [[ -r "$(brew --prefix)/share/zsh/site-functions/_brew" ]]; then
                fpath=($fpath $(brew --prefix)/share/zsh/site-functions)
                autoload -Uz compinit && compinit
            fi
            path=($path $(brew --prefix)/sbin $(brew --prefix)/bin $HOME/bin)
            alias ls="gls --color=auto"
            if [[ -r "$HOME/.iterm2_shell_integration.zsh" ]]; then
                source "$HOME/.iterm2_shell_integration.zsh"
            fi
            ;;
        LINUX)
            export NO_AT_BRIDGE=1
            alias open="xdg-open"
            alias ls="ls --color=auto"
            if [[ -x "/usr/bin/dircolors" ]]; then
                if [[ -r "$HOME/.dircolors" ]]; then
                    eval "$(dircolors -b "$HOME/.dircolors")"
                else
                    eval "$(dircolors -b)"
                fi
                alias ls="ls --color=auto"
                alias grep="grep --color=auto"
                alias fgrep="fgrep --color=auto"
                alias egrep="egrep --color=auto"
            fi
            export GCC_COLORS="error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01"
            ;;
    esac
}

# Aliases
setup_aliases() {
    alias grep="grep --color=auto -d skip"
    alias grpe="grep --color=auto -d skip"
    alias screen="tmux"
    alias ssh="ssh -A -o StrictHostKeyChecking=accept-new -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o ConnectTimeout=10 -o VisualHostKey=yes -o IdentitiesOnly=yes"
    alias nsr="netstat -rn"
    alias nsa="netstat -an | sed -n '1,/Active UNIX domain sockets/p'"
    alias lsock="sudo /usr/sbin/lsof -i -P"
    alias keypress="read -s -n1 keypress; echo \$keypress"
    alias :="cd .."
    alias ::="cd ../.."
    alias :::="cd ../../.."
    alias ::::="cd ../../../.."
    alias :::::="cd ../../../../.."
    alias ::::::="cd ../../../../../.."
}

# Functions
man() {
    env \
        LESS_TERMCAP_md=$'\e[1;36m' \
        LESS_TERMCAP_me=$'\e[0m' \
        LESS_TERMCAP_se=$'\e[0m' \
        LESS_TERMCAP_so=$'\e[1;40;92m' \
        LESS_TERMCAP_ue=$'\e[0m' \
        LESS_TERMCAP_us=$'\e[1;32m' \
        man "$@"
}

http_headers() {
    /usr/bin/curl -I -L "$@"
}

sshtunnel() {
    if [[ $# -ne 3 ]]; then
        echo "usage: sshtunnel host remote-port local_port"
    else
        /usr/bin/ssh "$1" -L "$3":localhost:"$2"
    fi
}

# Function to cat files and conditionally copy content to the clipboard based on the OS
catfiles() {
    local os_type=$(detect_shell_platform)
    local file
    local clip_cmd
    local all_contents=""

    # Determine the appropriate clipboard command based on the platform
    case "$os_type" in
        OSX)
            clip_cmd="pbcopy"
            ;;
        LINUX)
            # Check if running under WSL to use clip.exe
            if command -v clip.exe &>/dev/null; then
                clip_cmd="clip.exe"
            # Otherwise, use xclip or xsel if available
            elif command -v xclip &>/dev/null; then
                clip_cmd="xclip -selection clipboard"
            elif command -v xsel &>/dev/null; then
                clip_cmd="xsel --clipboard --input"
            else
                clip_cmd=""
            fi
            ;;
        *)
            clip_cmd=""
            ;;
    esac

    # Accumulate the contents of each file with filename headers
    for file in "$@"; do
        if [[ -f "$file" ]]; then
            all_contents+="Filename: $file\n"
            all_contents+=$(cat "$file" && echo "\n\n")
            echo "filename: $file added to clipboard content."
        else
            echo "Error: File $file does not exist."
        fi
    done

    # Pipe accumulated content to clipboard command or print to terminal
    if [[ -n $clip_cmd ]]; then
        echo "$all_contents" | $clip_cmd
        echo "All file contents copied to clipboard."
    else
        echo "$all_contents"
    fi
}

# Shell options
setup_shell_options() {
    setopt interactive_comments
    setopt long_list_jobs
    setopt prompt_subst
    setopt rm_star_silent
}

# Dircolors setup
setup_dircolors() {
    if [[ "$TERM" != "dumb" ]]; then
        local dircolors_cmd="$(whence gdircolors 2>/dev/null || whence dircolors 2>/dev/null)"
        local dir_colors="$HOME/.dircolors"
        if [[ -x "$dircolors_cmd" ]] && [[ -r "$dir_colors" ]]; then
            eval "$($dircolors_cmd -b "$dir_colors")"
        elif [[ -x "$dircolors_cmd" ]]; then
            eval "$($dircolors_cmd -b)"
        else
            echo "No dircolors command found, using default LS_COLORS"
        fi
        alias grep="grep --color=auto"
        alias fgrep="fgrep --color=auto"
        alias egrep="egrep --color=auto"
    fi
}

# Readline setup
setup_readline() {
    # Enable vi command mode
    bindkey -v

    # Basic navigation bindings
    bindkey '^A' beginning-of-line
    bindkey '^E' end-of-line
    bindkey '^D' delete-char
    bindkey '^L' clear-screen

    # History search bindings
    bindkey '^R' history-incremental-search-backward
    bindkey '\e[A' history-beginning-search-backward
    bindkey '\e[B' history-beginning-search-forward
}

# Completions
setup_completions() {
    autoload -Uz compinit
    compinit
    
    # Command specific completions
    compdef _command command
    compdef _signal kill
    compdef _user finger pinky
    
    # Directory handling completions
    compdef _directories cd
    compdef _directories pushd
    compdef _directories mkdir
    compdef _directories rmdir
    
    # File and job handling completions
    compdef _files ln chmod chown chgrp
    compdef _jobs fg bg disown jobs
}


# pyenv setup
setup_pyenv() {
    export PYENV_ROOT="$HOME/.pyenv"
    if [[ -d "$PYENV_ROOT/bin" ]] && [[ -x "$PYENV_ROOT/bin/pyenv" ]]; then
        path=($PYENV_ROOT/bin $path)
        eval "$(pyenv init -)"
    fi
}

# Check and add cron job for backing up shell history
ensure_cron_job_exists() {
    local cron_job="0 0 * * 0 . $HOME/.zshrc; backup_shell_history"
    if ! crontab -l | grep -Fq "$cron_job"; then
        (crontab -l 2>/dev/null; echo "$cron_job") | crontab -
        echo "Cron job added for backing up shell history."
    else
        echo "Cron job already exists."
    fi
}

# Backup shell history
backup_shell_history() {
    local backup_dir="$HOME/.shell_history_backups"
    mkdir -p "$backup_dir"
    local timestamp=$(date +"%Y%m%d%H%M%S")
    tar -czf "$backup_dir/zsh_history_$timestamp.tar.gz" -C "$HOME" .zsh_history
}

