#!/bin/zsh

# Constants
readonly AGENT_SOCKET="$HOME/.ssh/.ssh-agent-socket"
readonly AGENT_INFO="$HOME/.ssh/.ssh-agent-info"

# Detect only the architecture
detect_architecture() {
    local arch=$(uname -m)
    case "$arch" in
        x86_64) echo 'x86_64' ;;
        aarch64|arm64) echo 'arm64' ;;  # Handle both identifiers for ARM64
        *) echo 'unknown' ;;
    esac
}

# Detect shell platform
detect_shell_platform() {
    case "$OSTYPE" in
        linux*) echo 'LINUX' ;;
        darwin*) echo 'OSX' ;;
        freebsd*) echo 'BSD' ;;
        cygwin*) echo 'CYGWIN' ;;
        *) echo 'OTHER' ;;
    esac
}

# History management
setup_history() {
    # Path to the history file
    export HISTFILE="$HOME/.zsh_history"

    # Number of commands to save in the history file
    export HISTSIZE=10000
    export SAVEHIST=10000

    # Options to manage how history is stored and shared
    setopt SHARE_HISTORY          # Share history between all sessions
    setopt INC_APPEND_HISTORY_TIME
    setopt HIST_EXPIRE_DUPS_FIRST # Expire duplicate entries first when trimming history
    setopt HIST_REDUCE_BLANKS     # Remove superfluous blanks before saving entry
    setopt HIST_IGNORE_ALL_DUPS   # Ignore duplicated entries
    setopt HIST_IGNORE_SPACE      # Don't record an entry starting with a space
    setopt HIST_FIND_NO_DUPS      # Do not display duplicates in history search
    setopt HIST_VERIFY            # Show command with history expansion to user before running it
}


# Handles the initialization and maintenance of an SSH agent to manage SSH keys.
handle_ssh_agent() {
    local ssh_agent_info="$HOME/.ssh/.ssh-agent-info"
    local agent_socket="$HOME/.ssh/.ssh-agent-socket"

    # Load existing agent configuration if available
    if [[ -s "$ssh_agent_info" ]]; then
        source "$ssh_agent_info"
    fi

    # Check if SSH agent needs restarting
    if ! ssh-add -l &>/dev/null || [[ ! -S "$agent_socket" ]]; then
        restart_ssh_agent "$agent_socket" "$ssh_agent_info"
    fi
}

# Restarts the SSH agent and updates the agent information files
restart_ssh_agent() {
    local agent_socket=$1
    local agent_info_file=$2

    # Ensure old sockets are removed for security
    [[ -S "$agent_socket" ]] && rm "$agent_socket"

    # Start new SSH agent and save its configuration
    echo "Starting new SSH agent..."
    ssh-agent -a "$agent_socket" > "$agent_info_file"
    source "$agent_info_file"
    ssh-add
}

# Update PS1 prompt
update_ps1() {
    local os_type=$(detect_shell_platform)
    local arch_type=$(detect_architecture)
    local platform_cmd="${os_type}-${arch_type}"
    local powerline_cmd

    case "$platform_cmd" in
        OSX-x86_64) powerline_cmd="$HOME/bin/powerline-go-darwin-amd64" ;;
        OSX-arm64) powerline_cmd="$HOME/bin/powerline-go-darwin-arm64" ;;
        LINUX-arm64) powerline_cmd="$HOME/bin/powerline-go-linux-arm64" ;;
        LINUX-x86_64) powerline_cmd="$HOME/bin/powerline-go-linux-amd64" ;;
    esac

    # Check if the powerline_cmd is executable
    if [[ -n "$powerline_cmd" ]] && [[ -x "$powerline_cmd" ]]; then
        PS1="$($powerline_cmd -error $? -jobs $(jobs -p | wc -l))"
    else
        echo "Error: powerline-go command not found or not executable at $powerline_cmd"
        PS1="[%n@%m %~]%# "
    fi
}


# Sets up the general environment variables and configurations.
setup_environment() {
    setup_path
    setup_locale
    setup_editors
    setup_misc
    setup_fzf
}

# Configures system and user paths.
setup_path() {
    local system_paths=("/usr/local/bin" "/usr/local/go/bin")
    local user_paths=("$HOME/bin" "$HOME/.local/bin")
    local os_type=$(detect_shell_platform)

    if [[ "$os_type" == "OSX" ]]; then
        path=($(/opt/homebrew/bin/brew --prefix)/bin $(/opt/homebrew/bin/brew --prefix)/sbin $path)
    else
        path=($path $HOME/bin /usr/local/bin $HOME/.local/bin /usr/local/go/bin)
    fi
}

# Sets up locale and timezone settings.
setup_locale() {
    export LC_ALL="en_US.UTF-8"
    export LANG="en_US.UTF-8"
    export TZ="US/Pacific"
}

# Configures default editors and related settings.
setup_editors() {
    export EDITOR="vim -f"
    export P4EDITOR="$EDITOR"
    export VISUAL="$EDITOR"
}

# Miscellaneous environment settings.
setup_misc() {
    export VAGRANT_DEFAULT_PROVIDER="aws"
    export GCC_COLORS="error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01"
}

setup_fzf() {
    local os_type=$(detect_shell_platform)
    local arch_type=$(detect_architecture)
    local platform_cmd="${os_type}-${arch_type}"
    local fzf_cmd
    local common_fzf_link="$HOME/bin/fzf"

    case "$platform_cmd" in
        OSX-x86_64) fzf_cmd="$HOME/bin/fzf-darwin-amd64" ;;
        OSX-arm64) fzf_cmd="$HOME/bin/fzf-darwin-arm64" ;;
        LINUX-arm64) fzf_cmd="$HOME/bin/fzf-linux-arm64" ;;
        LINUX-x86_64) fzf_cmd="$HOME/bin/fzf-linux-amd64" ;;
    esac

    # Check if the specific binary exists and is executable
    if [[ -n "$fzf_cmd" ]] && [[ -x "$fzf_cmd" ]]; then
        # Only create symlink if it does not already exist or points to a different target
        if [[ ! -L "$common_fzf_link" ]] || [[ "$(readlink -- "$common_fzf_link")" != "$fzf_cmd" ]]; then
            ln -sf "$fzf_cmd" "$common_fzf_link"
        fi
    fi
}


# GOPATH setup
setup_gopath() {
    if [[ -z "$GOPATH" ]]; then
        export GOPATH="$HOME/workspace/go"
        mkdir -p "$GOPATH"
        path=($path $GOPATH/bin)
        export GOPROXY="https://proxy.golang.org,direct"
    fi
}

# Platform-specific aliases and setup
setup_platform_specific() {
    local os_type=$(detect_shell_platform)

    case "$os_type" in
        OSX)
            export HOMEBREW_NO_ANALYTICS=1
            #alias slock='pmset displaysleepnow && ssh 172.17.122.15 "DISPLAY=:0 slock"'
            alias brew="/opt/homebrew/bin/brew"
            if (( $+commands[brew] )) && [[ -r "$(brew --prefix)/share/zsh/site-functions/_brew" ]]; then
                fpath=($fpath $(brew --prefix)/share/zsh/site-functions)
                autoload -Uz compinit && compinit
            fi
            path=($path $(brew --prefix)/sbin $(brew --prefix)/bin $HOME/bin)
            alias ls="gls --color=auto"
            if [[ -r "$HOME/.iterm2_shell_integration.zsh" ]]; then
                source "$HOME/.iterm2_shell_integration.zsh"
            fi
            ;;
        LINUX)
            export NO_AT_BRIDGE=1
            alias open="xdg-open"
            alias ls="ls --color=auto"
            if [[ -x "/usr/bin/dircolors" ]]; then
                if [[ -r "$HOME/.dircolors" ]]; then
                    eval "$(dircolors -b "$HOME/.dircolors")"
                else
                    eval "$(dircolors -b)"
                fi
                alias ls="ls --color=auto"
                alias grep="grep --color=auto"
                alias fgrep="fgrep --color=auto"
                alias egrep="egrep --color=auto"
            fi
            export GCC_COLORS="error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01"
            ;;
    esac
}

git_cleanup() {
    git fetch --prune
    git branch --merged | grep -v "\*" | xargs -n 1 git branch -d
}

docker_cleanup() {
    docker system prune -af
    docker volume prune -f
}

# Aliases
setup_aliases() {
    alias gclean="git_cleanup"
    alias dclean="docker_cleanup"
    alias grep="grep --color=auto -d skip"
    alias grpe="grep --color=auto -d skip"
    alias screen="tmux"
    alias ssh="ssh -A -o StrictHostKeyChecking=accept-new -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o ConnectTimeout=10 -o VisualHostKey=yes -o IdentitiesOnly=yes"
    alias nsr="netstat -rn"
    alias nsa="netstat -an | sed -n '1,/Active UNIX domain sockets/p'"
    alias lsock="sudo /usr/sbin/lsof -i -P"
    alias keypress="read -s -n1 keypress; echo \$keypress"
    alias :="cd .."
    alias ::="cd ../.."
    alias :::="cd ../../.."
    alias ::::="cd ../../../.."
    alias :::::="cd ../../../../.."
    alias ::::::="cd ../../../../../.."
}

# Functions
man() {
    env \
        LESS_TERMCAP_md=$'\e[1;36m' \
        LESS_TERMCAP_me=$'\e[0m' \
        LESS_TERMCAP_se=$'\e[0m' \
        LESS_TERMCAP_so=$'\e[1;40;92m' \
        LESS_TERMCAP_ue=$'\e[0m' \
        LESS_TERMCAP_us=$'\e[1;32m' \
        man "$@"
}

http_headers() {
    /usr/bin/curl -I -L "$@"
}

sshtunnel() {
    if [[ $# -ne 3 ]]; then
        echo "usage: sshtunnel host remote-port local_port"
    else
        /usr/bin/ssh "$1" -L "$3":localhost:"$2"
    fi
}

# Function to cat files and conditionally copy content to the clipboard based on the OS
catfiles() {
    local os_type=$(detect_shell_platform)
    local file
    local clip_cmd
    local all_contents=""

    # Determine the appropriate clipboard command based on the platform
    case "$os_type" in
        OSX)
            clip_cmd="pbcopy"
            ;;
        LINUX)
            # Check if running under WSL to use clip.exe
            if command -v clip.exe &>/dev/null; then
                clip_cmd="clip.exe"
            # Otherwise, use xclip or xsel if available
            elif command -v xclip &>/dev/null; then
                clip_cmd="xclip -selection clipboard"
            elif command -v xsel &>/dev/null; then
                clip_cmd="xsel --clipboard --input"
            else
                clip_cmd=""
            fi
            ;;
        *)
            clip_cmd=""
            ;;
    esac

    # Accumulate the contents of each file with filename headers
    for file in "$@"; do
        if [[ -f "$file" ]]; then
            all_contents+="Filename: $file\n"
            all_contents+=$(cat "$file" && echo "\n\n")
            echo "filename: $file added to clipboard content."
        else
            echo "Error: File $file does not exist."
        fi
    done

    # Pipe accumulated content to clipboard command or print to terminal
    if [[ -n $clip_cmd ]]; then
        echo "$all_contents" | $clip_cmd
        echo "All file contents copied to clipboard."
    else
        echo "$all_contents"
    fi
}

# Shell options
setup_shell_options() {
    setopt interactive_comments
    setopt long_list_jobs
    setopt prompt_subst
    setopt rm_star_silent
}

# Dircolors setup
setup_dircolors() {
    if [[ "$TERM" != "dumb" ]]; then
        local dircolors_cmd="$(whence gdircolors 2>/dev/null || whence dircolors 2>/dev/null)"
        local dir_colors="$HOME/.dircolors"
        if [[ -x "$dircolors_cmd" ]] && [[ -r "$dir_colors" ]]; then
            eval "$($dircolors_cmd -b "$dir_colors")"
        elif [[ -x "$dircolors_cmd" ]]; then
            eval "$($dircolors_cmd -b)"
        else
            echo "No dircolors command found, using default LS_COLORS"
        fi
        alias grep="grep --color=auto"
        alias fgrep="fgrep --color=auto"
        alias egrep="egrep --color=auto"
    fi
}

# Readline setup
setup_readline() {
    # Enable vi command mode
    bindkey -v

    # Basic navigation bindings
    bindkey '^A' beginning-of-line
    bindkey '^E' end-of-line
    bindkey '^D' delete-char
    bindkey '^L' clear-screen

    # History search bindings
    bindkey '^R' history-incremental-search-backward
    bindkey '^\e[A' up-line-or-search
    bindkey '^\e[B' down-line-or-search
}

# Completions
setup_completions() {
    autoload -Uz compinit
    compinit
    
    # Command specific completions
    compdef _command command
    compdef _signal kill
    compdef _user finger pinky
    
    # Directory handling completions
    compdef _directories cd
    compdef _directories pushd
    compdef _directories mkdir
    compdef _directories rmdir
    
    # File and job handling completions
    compdef _files ln chmod chown chgrp
    compdef _jobs fg bg disown jobs
}


# pyenv setup
setup_pyenv() {
    export PYENV_ROOT="$HOME/.pyenv"
    if [[ -d "$PYENV_ROOT/bin" ]] && [[ -x "$PYENV_ROOT/bin/pyenv" ]]; then
        path=($PYENV_ROOT/bin $path)
        eval "$(pyenv init -)"
    fi
}

# Check and add cron job for backing up shell history
ensure_cron_job_exists() {
    local cron_job="0 0 * * 0 . $HOME/.zshrc; backup_shell_history"
    if ! crontab -l | grep -Fq "$cron_job"; then
        (crontab -l 2>/dev/null; echo "$cron_job") | crontab -
    fi
}

# Backup shell history
backup_shell_history() {
    local backup_dir="$HOME/.shell_history_backups"
    mkdir -p "$backup_dir"
    local timestamp=$(date +"%Y%m%d%H%M%S")
    tar -czf "$backup_dir/zsh_history_$timestamp.tar.gz" -C "$HOME" .zsh_history
}

notify_mac() {
    local title="$1"
    local message="$2"
    osascript -e "display notification \"$message\" with title \"$title\""
}

notify_linux() {
    local title="$1"
    local message="$2"
    notify-send "$title" "$message"
}

notify_windows() {
    local title="$1"
    local message="$2"
    powershell -Command "& {Add-Type -AssemblyName PresentationFramework; [System.Windows.MessageBox]::Show('$message', '$title')}"
}

notify_cross_platform() {
    local title="$1"
    local message="$2"
    if command -v zenity &> /dev/null; then
        zenity --info --title="$title" --text="$message"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        osascript -e "display notification \"$message\" with title \"$title\""
    elif command -v notify-send &> /dev/null; then
        notify-send "$title" "$message"
    elif command -v powershell &> /dev/null; then
        powershell -Command "& {Add-Type -AssemblyName PresentationFramework; [System.Windows.MessageBox]::Show('$message', '$title')}"
    else
        echo "Notification not supported on this OS."
    fi
}


notify_shell_status() {
    local title="Shell Status"
    local message=""

    # Check for new mail
    if [[ -n "$(find /var/mail -type f -newer ~/.last_mail_check 2>/dev/null)" ]]; then
        message+="You have new mail."
    fi

    # Check SSH agent status
    if [[ -n "$SSH_AGENT_PID" ]]; then
        message+="SSH Agent (PID: $SSH_AGENT_PID) is running."
    else
        message+="SSH Agent is not running."
    fi

    # Check fzf setup status
    if [[ -x "$HOME/bin/fzf" ]]; then
        message+="fzf is properly set up."
    else
        message+="fzf is not set up."
    fi

    # Check cron job status
    if crontab -l | grep -Fq "backup_shell_history"; then
        message+="Cron job for backing up shell history exists."
    else
        message+="Cron job for backing up shell history does not exist."
    fi

    local reset="\033[0m"
    local bold="\033[1m"
    local red="\033[31m"
    local green="\033[32m"
    local yellow="\033[33m"
    local blue="\033[34m"

    # Display the ANSI BBS-style welcome message
    clear
    echo -e "${bold}${blue}+----------------------------------+${reset}"
    echo -e "${bold}${blue}|                                  |${reset}"
    echo -e "${bold}${blue}|        ${yellow}Welcome to My Shell${reset}${bold}${blue}       |${reset}"
    echo -e "${bold}${blue}|                                  |${reset}"
    echo -e "${bold}${blue}+----------------------------------+${reset}"
    echo

    # Display the shell status information
    echo -e "${bold}${green}Shell Status:${reset}"
    echo -e "  ${yellow}New Mail:${reset} $(if [[ -n "$(find /var/mail -type f -newer ~/.last_mail_check 2>/dev/null)" ]]; then echo "Yes"; else echo "No"; fi)"
    echo -e "  ${yellow}SSH Agent:${reset} $(if [[ -n "$SSH_AGENT_PID" ]]; then echo "Running (PID: $SSH_AGENT_PID)"; else echo "Not Running"; fi)"
    echo -e "  ${yellow}fzf Setup:${reset} $(if [[ -x "$HOME/bin/fzf" ]]; then echo "Properly Set Up"; else echo "Not Set Up"; fi)"
    echo -e "  ${yellow}Cron Job:${reset} $(if crontab -l | grep -Fq "backup_shell_history"; then echo "Exists"; else echo "Not Found"; fi)"
    echo

    # Display additional system information based on the platform
    local os_type=$(detect_shell_platform)
    echo -e "${bold}${green}System Information:${reset}"
    echo -e "  ${yellow}System Load:${reset} $(uptime | awk -F'[a-z]:' '{ print $2 }')"

    # Run the slower parts in background jobs
    case "$os_type" in
        OSX)
            memory_usage_job="$(vm_stat | awk '/Pages active:/ { printf "%.2f GB", $3 * 4096 / 1024 / 1024 / 1024 }')"
            disk_usage_job="$(df -h / | awk '/\// {print $(NF-1)}')"
            ip_address_job="$(ipconfig getifaddr en0)"
            last_login_job="$(last -1 $USER | awk 'NR==1 { print $3, $4, $5, $6 }')"
            uptime_job="$(sysctl -n kern.boottime | awk '{print $4}' | sed 's/,//g')"
            ;;
        LINUX)
            memory_usage_job="$(free -h | awk '/^Mem:/ { print $3 "/" $2 }')"
            disk_usage_job="$(df -h / | awk '/\// {print $(NF-1)}')"
            ip_address_job="$(ip -4 addr show | awk '/inet/ { print $2 }' | cut -d/ -f1 | head -n1)"
            last_login_job="$(last -1 $USER | awk 'NR==2 { print $3, $4, $5, $6 }')"
            uptime_job="$(uptime -p)"
            ;;
    esac

    # Wait for all background jobs to complete
    wait

    # Display the collected information
    echo -e "  ${yellow}Memory Usage:${reset} $memory_usage_job"
    echo -e "  ${yellow}Disk Usage:${reset} $disk_usage_job"
    echo -e "  ${yellow}IP Address:${reset} $ip_address_job"

    if [[ -n "$last_login_job" ]]; then
        echo -e "  ${yellow}Last Login:${reset} $last_login_job"
    else
        echo -e "  ${yellow}Last Login:${reset} Not available"
    fi

    case "$os_type" in
        OSX)
            local current_time=$(date +%s)
            local boot_time=$uptime_job
            local uptime=$((current_time - boot_time))
            local days=$((uptime / 86400))
            local hours=$(((uptime % 86400) / 3600))
            local minutes=$(((uptime % 3600) / 60))
            echo -e "  ${yellow}System Uptime:${reset} ${days} days, ${hours} hours, ${minutes} minutes"
            ;;
        LINUX)
            echo -e "  ${yellow}System Uptime:${reset} $uptime_job"
            ;;
    esac

    echo
}
